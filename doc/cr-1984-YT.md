# An Efficient Channel Router

Takeshi Yoshimura

NEC Corporation
4-1-1, Miyazaki, Miyamae-ku
Kawasaki 213, JAPAN

## Abstract

In the LSI chip layout design, channel routing is one of the key problems.
The problem is to route a spcified net list between two rows of terminals
across a two layer channel.

This paper presents a new routing algorithm, which is an improved version of
the classical “left edge algorithm”. The new algorithm uses a row by row
approach, calculating an optimum net assignment to each row.

The algorithm was implemented for examples in previously published papers.
Experimental results show that the new algorithm produces optimum solutions
in most cases.

## 1 Introduction

Among several routing strategies for LSI
layout, channel routing is the most important,
because

1. it is efficient and simple,
2. it guarantees 100-percent completion if constraints are noncyclic and
   channel height is adjustable, and
3. it is used in the layout design of custom chips as well as uniform
   structures such as gate arrays or polycells.

Since a channel routing algorithm, called “left edge”, was first proposed by
Hashimoto and Stevens (1), various algorithms were proposed and significant
results have been obtained quite recently (2,3,4,5).

This paper proposes a new algorithm which is an improved version of the “left
edge algorithm”. This method was tested using the same examples provided by
previous authors. Experimental results show that the method is quite efficent
and produces optimum solutions in most cases.

## 2 Problem description

Consider a rectangular channel with two rows of terminals along its top and
bottom. A number between 0 and N is assigned to each terminal. Terminals with
the same number i (1 ≤ i ≤ N) must be connected by net i, while those with
number 0 designated unconnected terminals.

Two layers are available for routing. It is assumed there are horizontal
tracks on one layer and vertical tracks on the other. Nets are laid on
tracks. Horizontal tracks are isolated from vertical tracks, and connection
between them are made through via holes. The problem is expressed by a net
list, as shown in Fig 1. Arrows indicate whether nets are to be connected to
the terminals on the upper or lower sides of the channel.

Fig 1: Netlist representation for routing requirement

    (0 1 4 5 1 6 7 0 4 9 10 10)
    (2 3 5 3 5 2 6 8 9 8  7  9)

Let us consider the example in Fig 2-a. Because the vertical segment of net 1
cannot overlap that of net 2 (shown by dotted line) on the same vertical
track, a constraint relation has been introduced on the horizontal segments
on net 1 and net 2. If attention is paid to the left most column, the
horizontal segment of net 1 must be placed above that of net 2. By the same
reasoning, net 2 must be placed above net l, if the rightmost column is
considered. In other words, the routing specification cannot be realized
without splitting some net into more than one horizontal segments, as shown
in Fig 2-b. However, this kind of conflicting situation can often be avoided
by rearranging the placement. In this paper, it is assumed that routing
specifications are always realizable, in the sense that no cyclic conflict
exists in the netlist.

Fig 2: Cyclic conflict and dogleg

The major objective of the problem is to minimize the number of horizontal
tracks used to realize the routing requirement.

Consider the example in Fig 2-c, where an optimal solution is given if
horizontal segment splitting is not allowed. However, the same example can be
realized with only two tracks by horizontal splitting, as shown in Fig 2-d.

Splitting horizontal segments of nets is called “doglegging.” This is not
only used to to avoid vertical routing conflict, as mentioned above, but is
also used to minimize the number of horizontal tracks. In the case of
doglegging, it is assumed that horizontal splitting is allowed at the
terminal positions only, which implies no additional vertical tracks is used.

## 3 Definitions

### 3.1 Netlist

The problem is expressed by a netlist, as shown in Fig 3-a. Arrows indicate
whether nets are to be connected to terminals on the upper or lower sides of
the channel.

Fig 3: Examples of netlist, vertical constraint graph, and zone
representation

### 3.2 Vertical constraint graph

As mentioned earlier, no two nets can overlap at a vertical column. If it is
assumed that there is only one horizontal segment per net, then it is clear
that the horizontal segment of a net connected to the upper terminal at a
given column must be placed above the horizontal segment of another net
connected to the lower terminal at that column. This relation can be
represented by a directed graph Gv, where each node corresponds to a net and
a directed edge from net a to net b means that net a must be placed above net
b (Fig 3-b). Therefore, if there is a cycle, the routing requirement cannot
be realized without dividing some nets. (For example, a cycle a → b → c → a
means that net a must be placed above itself.) However, it should be noted
here that, if the vertical constraint graph is acyclic, the routing
specification is always realizable.

### 3.3 Ancestor and descendent

Node i is said to be an ancestor of node j (node j is a descendent of node
i), if there is a directed path from node i to node j in the vertical
constraint graph.

### 3.4 Zone representation for horizontal segments

The horizontal segment in a net is determined by its leftmost and rightmost
terminal connections. Let S(i) be the set of nets whose horizontal segments
intersect column i. Since horizontal segments of distinct nets must not
overlap, the horizontal segments of any two nets in S(i) must not be placed
on the same horizontal track. This condition must be satisfied at every
column. However, it is easy to see that it is only necessary to consider
those S(i) which are not subsets of other sets. Therefore, a sequential
number is assigned to the columns at which S(i) are maximal. These columns
define zone 1, zone 2, etc. as shown in Table 1, for the example in Fig 3-a.
The number of elements in S(i) is called local density, and the maximum among
them is called maximum density.

Table 1

Clearly, we need not consider S(1) or S(2), because the horizontal
constraints related to these sets are included in that for S(3). The zone
representation for this example is shown in Fig 3-c.

Zones can be defined more clearly by using an interval graph defined by the
horizontal segments of nets (2).

### 3.5 Dogleg

Up to now the vertical constraint graph and the zone representation were
defined for the problem where the number of horizontal segments per net is
limited to one, i.e., the realization does not allow doglegs. However, these
two representations can be extended to the dogleg problem, where the
horizontal segment of a net can be divided at its terminal positions. In this
case, subnets whose horizontal segments are parts of a net between two
consecutive terminals, are introduced (2).

### 3.6 Additional comments on dogleg

Of course, the dogleg problem can be solved using the zone representation and
the vertical constraint graph for the subnets introduced above, but
additional consideration may be necessary to reduce the number of doglegs and
computation time. Thus, a preprocess, “merging of subnets” is introduced
which merges subnets belonging to the same net to form a net or larger
subnet. If we carry this process out to its extreme, the problem is reduced
to the no-dogleg problem. Hence, the following restriction is imposed on the
subnet merging.

Subnet i and subnet j can be merged, only if merging of these two subnets
will not increase the length of the longest paths which pass through node i
or node j on the vertical constraint graph.

According to the results of the preliminary experiments, this process
significantly reduces the computation time and improves the solution, in the
sense that the number of horizontal tracks and the number of doglegs are both
reduced.

## 4 Left Edge Algorithm

Before describing the new algorithm, the left edge algorithm will be
explained. The basic idea is as follows. The algorithm processes horizontal
tracks sequentially from the top one to the bottom one. At each iteration
(say, for track i), the “left most net” among those which have no ancestors
in the vertical constraint graph is routed on the track. The process is
repeated until no additional nets can be placed on track i without violating
the constraints. The algorithm always produces a feasible solution, if no
conflict loops exist in the vertical constraint graph.

The algorithm is illustrated using the example in Fig 4. In the example, net
1, net 4 and net 10, which have no ancestors in the vertical constraint
graph, are the candidates for track 1. The algorithm routes net 1 (one of the
leftmost nets), and then net 10 on the track. The vertical constraint graph
and the zone representation are updated, as shown in Fig 5, because net 1 and
net 10 have been routed. The candidates for the second track are net 4 and
net 7. Among them, net 4 is placed because of the position in the zone
representation. The algorithm repeats the iterations, finally yielding the
solution in Fig 6.

Fig 4: Examples of netlist, vertical constraint graph, and zone
representation

Fig 5: Updated vertical constraint graph and zone representation

Fig 6: Solution of the left edge algorithm

The solution obtained above is optimum. However, in the case of the problem
in Fig 7, the algorithm may not produce an optimum solution. In this example,
both net 1 and net 2 can be placed on track 1. Let us assume that net 1 is
selected first. Then, the solution in Fig 8-a will be obtained. It requires
three tracks, while the same example can be routed with only two tracks, as
shown in Fig 8-b. As illustrated above, the left edge algorithm does not
necessarily find good solutions.

Fig 7: Example for which the left edge algorithm may not produce an optimum
solution

Fig 8: Solutions of the problem in Fig 7: (a) Solution of the left edge
algorithm; (b) Optimum solution

The following section proposes a new algorithm, which is an improved version
of the left edge algorithm.

## 5 Improved Algorithm

One of the drawbacks of the left edge algorithm is that it selects nets to
place on horizontal tracks without taking into account the longest path
length in the vertical constraint graph. If the longest path length is L at
some iteration, the assigmnent of the remaining nets requires at least L
additional tracks. Therefore, it is desirable to select nets such that their
removal will decrease the path lengths in the vertical constraint graphs. In
the example in Fig 7, net 2 is on the longest path in the vertical constraint
graph. If the algorithm routes net 2 instead of net 1 on track 1, it will
yield the optimum solution, as shown in Fig 8-b. Thus, the key algorithm
problem is how to choose the nets to place on the horizontal track being
processed at each iteration.

An immediate method to improve the left edge algorithm is to choose the net
on a longer path in the case of tie, i.e., more than one nets have their left
ends in the same zone. As stated above, this method leads to the optimum
solution for the example in Fig 7. However, let us consider the routing
reqirement in Fig 9, where net 1 and net 2 are the candidates for track 1.
Since there is no tie and the “left most net” is net 1, the method routes net
1 on track i. Then, the solution requires at least 4 tracks, no matter what
the assignment of the remaining nets will be. In fact, the solution in
Fig 10-a will be obtained. On the other hand, if net 2 which is on the
longest path is chosen for track 1, then the optimal solution in Fig 10-b
will be produced.

Fig 9: Routing requirement example: (a) net list; (b) vertical constraint
graph; (c) zone representation

Fig 10: SolutionSof the problem in Fig 9

Hence, another method is considered, which chooses the net to be placed next,
among the candidates for the track being processed, depending only on the
path lengths in the vertical constraint graph. In the previous example, the
method places net 2 on track 1, because it is on a longer path than net 1 is,
and yields an optimum solution. As for the example in Fig 11, however, the
same method yields the non-optimum solution in Fig 12-a, because it assigns
net 1 and net 2 on track 1 ,leaving a lot of unoccupied area on the track,
while the previous method produces the optimum solution, as shown in Fig
12-b.

Fig 11: Another example of routing requirement: (a) net list; (b) vertical
constraint graph; (c) zone representation

Fig 12: Solutions of the problem in Fig 11

Considering these examples, it is desirable to choose nets, not only taking
into account the longest path length, but also trying to minimize the wasted
area in the track being processed.

Thus, the following algorithm is proposed.

### Algorithm

1. construct the vertical constraint graph and the zone representation. Let
   N = {set of all nets}, T = 1
2. while N ≠ ∅ do
3. No = {set of nets which have no ancestors in the vertical constraint graph}
4. find Na ⊆ No such that
   1. no two nets in Na do not have horizontal segments overlaps;
   2. ∑ Wn → max for n ∊ Na, where Wn is the weight assigned to net n.
5. place all nets in Na on track T, let N = N - Na.
6. update the vertical constraint graph and the zone representation.
7. T = T + 1
8. end

The algorithm is the same as the left edge algorithm, except for step 4. In
step 4 in the left edge algorithm, the algorithm chooses set Na, depending
only on the horizontal position of nets, without considering other
informations, such as the longest path length, etc.

In the following, step 4 in the proposed algorithm will be explained. In the
step, non negative weight Wn is assigned to unplaced net n. The weight of
each net is determined depending on the longest path length passing through
the net, the net horizontal segment length, the local density of the zones
the net belonging to, etc.

For the zone representation in Fig 13-a, let No and net weights are assumed,
as shown below.

    No = {1,2,3,4,5,6}
    (WI,W2,W3,W4,W5,W6) = (3,3,2,2,1,1)

Then, it is easy to see the set of nets Na is

    Na = {2,4,5}

and

    ∑ Wn = 7 for n ∊ Na.

Before describing the algorithm for finding the set Na, the basic idea will
be explained. Consider the net compatibility graph in Fig 13-b, where each
node corresponds to a net, and edge (i,j) means that no horizontal segments
overlap between net i and net j. Net weight Wn is assigned to the node
corresponding to net n. Obviously, Na is the set of nets corresponding to the
nodes on a longest path, on which total node weights is maximum. Hence, set
Na can be calculated by applying a longest path algorithm to the net
compatibility graph. An example of the longest path, which corresponds to the
set of nets {2,4,5} is shown by heavier lines in Fig 13-b. It is, however,
time consuming to construct the net compatibility graph.

Fig 13: Zone representation and net compatibility graph

Instead of the net compatibility graph, we express the relation between zones
and nets by another graph, where each zone corresponds to a node and a net
whose left end and right end are in zone i and zone j, respectively is
represented by edge (i-1,j). Furthermore, individual node pairs corresponding
to conseotive zones are connected by an edge. Net weights are assigned to the
edges corresponding to nets, while the weight of edges, which connect
consective zones, are defined as zero. The graph which corresponds to the
example in Fig 13-a is shown in Fig 14. It is easy to see that the set of
nets Na can be obtained from the set of edges on the longest path, on which
total edge weights is maximum. In Fig 14, heavier lines represent a longest
path which corrsponds to the set of nets {2,4,5}.

Fig 14: Another graph for calculating an optimum net assignment

The following algorithm is proposed which calculates the set of nets Na based
on the idea, though it does not deal with the graph explicitly. The algorithm
consists of phase 1 and phase 2.

### Phase 1

    begin
      comment ZS(N) : leftmost zone of net N
              ZE(N) : rightmost zone of net N
              W (N) : net weight
              ZN(Z) : set of nets in Na, whose left ends are in zone Z
              ZP(Z) : zone potential
              ZA(Z) : list structure representing Na
              #Z    : number of zones
    
      ZP(O) = O
      ZA(O) = O
    
      for I=1 to #Z do
        ZP(I) = ZP(I-I)
        ZA(I) = ZA(I-I)
    
        for N g ZN(I) do
          P = ZP(ZS(N)-1) + W(N)
    
          if P ≥ ZP(I) then
            ZP(I) = P
            ZA(I) = N
          end
        end
      end
    end

Table 2 shows array values at the algorithm termination. ZP(Z) and ZA(Z)
contain the longest path length from zone 0 to zone Z in Fig 13, and list
structure representing the set of edges on the longest path, respectively.

Table 2: Array values at the algorithm termination

Phase 2 in the algorithm generates set Na from the values of array ZA, which
is obtained at phase 1.

### Phase 2

    begin
      Na = {}
      N = ZA(#Z)
    
      while N ≠ 0 do
        Na = Na ⋃ {N}
        N  = ZA(ZS(N)-1)
      end
    end

In the case of the previous example, the set of nets {5,4,2} is calculated by
the algorithm.

Net weights should be determined by taking into account the longest path
lengths and node degrees (or numbers on incident edges) in the vertical
constraint graph, local densities in the zone representation, etc. Among a
lot of possible definitions of net weights, we choose the following.

First, for each zone Z, the zone weight Uz is defined by using weighting
function G as shown in the following:

    Uz = G(Dmax-Dz)

where Dmax and Dz are maximum density and local density, respectively.

### Example of function G

    G(0) = 10, G(1) = 5, G(2) = 3, G(3) = 2, G(4) = 1, G(5) = 0,..

Next, for each net n, net weight Wn is defined, as shown below.

    Wn = (∑ Uz for z ∊ Zn) + (P*Ln + Dn) * |Zn|

where

    Zn   : set of zones which net n belongs
           to in the zone representation,
    |Zn| : number of zones in Z(n),
    Ln   : length of the longest path which
           has node n on it in the vertical
           constraint graph,
    Dn   : degree of node n in the
           vertical constraint graph,
    P    : parameter.

### Example of net weight

For the routing specification in Fig 9, let Wp is 3 and Gz are picked as
defined in a previous example, then the weights of net 1 and net 2 are
calculated as shown in the following.

    W1 = U1 + U2 + (3*L1 + D1) * |Z1|
       =  5 +  5 + (3* 2 +  1) *  2
       = 24
    
    W2 = U2 + U3 + (3*L2 + D2) * |Z2|
       =  5 + 10 + (3* 3 +  1) *  2
       = 35

Hence, net 2 is routed on track 1 and the optimum solution in Fig 10 is
obtained.

As shown in the previous example, the new algorithm produces the optimum
solution for the routing specification in Fig 9. In the case of the example in
Fig 11, since the weights for net 1, net 2, net 3 and net 4 are 12, 12, 27 and
27, respectively, the same algorithm places net 1 and net 3 (or, net 2 and net
4) on track 1. It finally produces the optimum solution in Fig 11-c.

## 6 Experimental Results

The proposed algorithm has been coded in Fortran and implemented on a computer
whose performance is about 1 MIPS (1 Million Instructions Per Second).

### 6.1 Program

In the explanation of the algorithm, horizontal tracks are processed from the
top one to the bottom one. However, it is not necessary to follow the order. In
fact, better solutions were obtained when the top and the bottom of the
unprocessed tracks were routed alternatively, such as the top one, the bottom
one, the next to the top one, etc. Therefore, the program processes horizontal
track in this order.

### 6.2 Parameters

The algorithm has two parameters, Gz and P. In the experiment, however, there
were only slight differences among the solutions for various parameter values.
Therefore, the values, shown in the examples in the previous section, were
fixed.

### 6.3 Results

The program was executed on the data taken from an existing paper (2). Table 3
compares the number of horizontal tracks required for proposed algorithm, left
edge algorithm (Deutsch's algorithm (6) for the “difficult example”) and the
algorithm of Yoshimura and Kuh (2). The results indicate that the proposed
algorithm reaches the optimum solutions for the data “example 1” through
“example 5”.

For the “difficult example”, which has become a bench mark test for channel
routers, the “greedy” router (3) reaches 20 tracks and the “hierachical” router
(4) achieved a 19 track routing. The new algorthm reqires 20 tracks for the
routing (Fig 15), but it uses much less via holes than the two algorithms.
Another feature for the proposed algorithm is efficency. It requires only 0.59
seconds, while the algorithm proposed by Yoshimura and Kuh requires 1.21
seconds on the same machine.

Table 3: Experimental Results

## 7 Conclusion

This paper has proposed a new routing algorithm for the channel routing
problem. Like the left edge algorithm, the new algorithm processes a
horizontal track at each iteration, but it calculates an optimum net
assignment for each horizontal track, in the sense that total weight of
assigned nets is maximum. The new algorithm is very fast and produces near
optimum solutions in most cases.

The size of the program is around 1000 steps in Fortran, including input and
output subroutines. Since the algorithm is simple, it can easily be extended
to deal with irregular shaped channels. The extended program has been built
in a layout program for standard cell LSI.

## Acknowledgements

The author wishes to thank Dr. M. Naniwada, Dr. M. Takeya and Dr. S. Goto of
NEC Corporation, Prof. I. Shirakawa and Prof. S. Tsukiyama of Osaka
University and Prof. E.S. Kuh of U.C. Berkeley for their helpful
encouragement.

## References

1. A. Hashimoto, J. Stevens, “ire routing by optimizing channel assignment”,
   Proc. 8th DA Conf., 1971, pp 214-224.

2. T. Yoshimura, EoS. Kuh, “Efficient Algorithms for Channel Routing”, IEEE
   Trans. on CAD of ICs and Systems, Vol. CAD-1, No 1, 1982, pp 25-35.

3. R.L. Rivest, Fiduccia C.M., “A ‘Greedy’ Channel Router”, Proc. 19th DA
   Conf., 1982, pp 418-424.

4. M. Burstein, R. Pelavin, “Hierarchical Channel Router”, Proc. 20th DA
   Conf., 1983, pp 591-597.

5. A. Sangiovanni-Vincentelli, M. Santomauro, “YACR: Yet Another Channel
   Router”, Proc. IEEE Int. Symp. Circ. & Syst., 1983, pp 327-331.

6. D. Deutsch, “A dogleg channel router”, Proc. 13th DA Conf., 1976, pp
   425-433.

